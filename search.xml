<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[HTTP权威指南笔记]]></title>
      <url>%2F2017%2F03%2F22%2FHTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[起因在腾讯的一面之后，深感自身对HTTP细节知识的缺失，包括同源策略和缓存机制的不了解，当天即购入了著名的《HTTP权威指南》 这篇blog是一个索引，整合了我阅读《HTTP权威指南》一书的总结和自己的思考，包含一系列的文章 概述这一部分主要包含了书中的第一部分: 1、2、3、4 章 资源与URI HTTP报文 TCP/HTTP链接 结构这一部分主要包含了书中的第二部分: 5,6,7,8 章 HTTP缓存机制]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP-缓存机制]]></title>
      <url>%2F2017%2F03%2F22%2FHTTP-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[这是我阅读《HTTP权威指南》的总结和思考中，一系列文章的一篇，目录在这里 为什么需要缓存缓存主要解决了四个问题 冗余数据传输: 节约了网络费用 带宽瓶颈: 降低了传输时延(=文件大小/带宽) 瞬间拥塞: 对于一些突发时间, 降低了对服务器的要求, 避免了网络崩溃 距离时延: 降低了传播时延(距离/光纤速度) 缓存结构缓存分为两种: 私有缓存: 浏览器的临时文件 公有缓存: 特殊的代理服务器 拓扑结构又有两种: 层级结构: 越高层次缓存越大, 服务的用户越多, 私有缓存可以认为是第一级缓存 网状缓存/对等缓存: 多个不同组织之间共用缓存, 可以查询对等组织的缓存 缓存处理步骤对于一个代理缓存服务器, 其处理缓存主要由7步构成, 核心在于新鲜度检测与更新 接收、解析、查找 缓存服务器监测到客户端输入，读取数据，在全部报文抵达前开始处理 将请求报文分片解析，格式化为易于分析的数据结构 在自身的存储(内存或者磁盘)中快速寻找该资源副本，如果不存在就访问服务器申请 新鲜度检测新鲜度检测是缓存处理的核心，如果一个资源的副本不够新鲜，就要根据一定的策略向服务器查询该副本是否变化 文档过期 Cache-Control(HTTP/1.1): max-age： 定义一个以秒为最大单位的文档使用期限 1Cache-Control: max-age=484200 Expires(HTTP/1.0+)： 定义一个过期日期，依靠对本机日期(需要精确)和改日期比较确定是否过期 1Expires: Fri, 05 Jul 2002, 05:00:00 GMT 再验证如果同时携带两者，必须同时满足才可以发送304 If-Modified-Since: ：服务器通过比较文件的修改日期和该头部的日期，确定是返回304还是200+文件实体 1If-Modified-Since: Sat, 29 Jun 2002, 14:30:00 GMT If-None-Match: ：因为只用时间可能: 秒不够精确、未发生实际修改、服务器无法判断修改日期。所以资源返回一个ETag标签来标示是否修改 123456//RequestIf-None-Match: &quot;v2.6&quot;//Response304 Not ModifiedETag: &quot;v2.6&quot;Expires: ......(date) 响应、发送、日志 缓存创建响应，其中Date首部使用原始服务器的值让客户端知道这是一个缓存 发送创建的响应 缓存服务器记录与缓存相关数据，如命中率等 缓存控制策略控制策略服务器通过Cache-Control和Expires首部来控制客户端的缓存策略 no-Store: 不允许存储本地缓存文件，每次从服务器下载 no-Cache: 允许存储缓存，但是每次都必须与原是服务器进行再验证 max-age: 之前讨论过，表示新鲜度维持时间，=0类似于no-Cache must-revalidate: 有些缓存允许返回过期资源副本，设置该头部后，缓存只允许提供新鲜的副本，过期副本必须验证 Expires: 之前讨论过，依赖于服务器时间，不推荐使用 试探新鲜度如果没有设置新鲜度(max-age或Expires): 通常使用一些试探算法进行猜测，如LM算法1新鲜度 = LM因子(比如0.2) * (资源获取时间 - 资源最后修改时间) 如果无法获得最后修改日期，就只能直接设置为1小时或一天了 客户端新鲜度控制客户端也可以通过Cache-Control请求来强化或者放松对过期时间的限制 Cache-Control: max-stale (=&lt;s&gt;) 缓存可以提供过期文件，如果有参数s，最多过期s时间 Cache-Control: min-fresh = &lt;s&gt; 缓存在未来s秒内要保持新鲜 Cache-Control: max-age = &lt;s&gt; 缓存无法返回缓存时间大于s的资源 no-Cache or no-Store 必须再验证 or 必须尽快删除存储 only-if-cached 只有缓存存在副本，才获取一份副本]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP-TCP与链接管理]]></title>
      <url>%2F2017%2F03%2F22%2FHTTP-TCP%E4%B8%8E%E9%93%BE%E6%8E%A5%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP-报文]]></title>
      <url>%2F2017%2F03%2F21%2FHTTP-%E6%8A%A5%E6%96%87%2F</url>
      <content type="text"><![CDATA[这是我阅读《HTTP权威指南》的总结和思考中，一系列文章的一篇，目录在这里 组成HTTP报文分为两种：请求报文(request message)和响应报文(response message) 每一个报文都有三部分组成： 起始行(start line) 首部(header)，键值对，每一对占一行，最后由一个空行结束(无论有无body部分) 主体(body) 12345678910//请求报文&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;&lt;headers&gt;&lt;entity-body&gt;//响应报文&lt;version&gt; &lt;status&gt; &lt;reason-phrase&gt;&lt;headers&gt;&lt;entity-body&gt; 起始行方法(Method)方法包含GET, HEAD(这2个被认为是安全方法，即不对服务器产生副作用。同时也是HTTP1.1必须实现的两个方法), PUT, POST, TRACE, OPTIONS, DELETE以及扩展方法 GET用于请求服务器中的某个资源，HTTP/1.1中强制要求实现的方法 HEAD与GET方法类似，返回一个只有首部没有主体的响应报文，首部应该与GET返回的一致。HTTP/1.1强制要求实现 主要用于: 判断资源类型Content-Type、大小Context-Length等 PUTPUT命令让服务器在&lt;request-URL&gt;指定的路径创建/更新报文实体的内容，通常操作前需要密码认证 服务器如果操作成功，将返回 201 Created POST用于向服务器发送数据，与PUT的不同在于PUT是直接在服务器的文件上存储数据。 POST也被用来发送表单数据 TRACE一个报文可能经过防火墙、代理、网关或其他应用，TRACE允许客户端查看最终服务器收到的报文，检查是否有修改／损坏 服务器在TRACE响应报文的主体部分携带了他收到的请求，客户端可以对比响应主体中的报文来和自己发出的报文对比 OPTIONS查询服务器支持的方法(Method), 返回在Header里，例如 Allow: GET, POST, PUT。 在跨域CORS中具有应用 DELETE删除指定URL处的资源，但是服务器有可能并没有删除该资源(依然返回200 OK) 扩展方法HTTP允许扩展方法，即规范中没有写，开发者自定义的方法 状态码信息性状态码(100-101)如果客户端要向服务器发送一个大的实体前，发送一个带有头Expect: 100 Continue的报文，在收到100或者一定时间以后直接发送实体 成功状态码(200-206)不同的响应状态码对应不同请求方法(PUT,GET)的回应 重定向状态码(300-307)对于一个移走的资源，返回30x(如301永久移走)，可以附带一个可选的Location:URL头部，浏览器将自动再发送一个到该URL的请求，在使用者未注意到的情况下转入新位置 客户端可以发送一个特殊的If-Modified-Since: Date首部，如果未更改过，浏览器返回304，客户端直接使用本地副本 客户端错误代码(400-417)请求出现错误，比如请求一个不存在的URL(404)，权限不足，格式错误的报文等 服务器错误码(500-505)服务器自身出现了错误，比如某个子元素，网关资源出错等 首部通用首部提供了基本信息和缓存控制策略，请求和响应都可以使用 请求首部包括客户端信息类首部，Accept首部，条件请求首部，安全请求首部(包括Cookie)与代理请求首部 响应首部包括响应信息(时间，服务器版本)首部，协商首部，安全响应首部(Cookie) 实体首部信息首部(Allow和Location等)，内容首部(Content-Type,Length等)，缓存首部(ETag、Expires、Last-Modified)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP--资源与URI]]></title>
      <url>%2F2017%2F03%2F21%2FHTTP-%E8%B5%84%E6%BA%90%E4%B8%8EURI%2F</url>
      <content type="text"><![CDATA[这是我阅读《HTTP权威指南》的总结和思考中，一系列文章的一篇，目录在这里 什么是资源Web是由资源(Web resource)构成的，资源存放在服务器(Web Server)中，包含： 文件: 包括了各式各样的静态文件，HTML、CSS、JavaScript、图片、音乐、视频 网关: 网关是特殊的服务器，作为中间实体生成或者从其他位置请求资源，包括了各种动态生成返回的服务，例如股票信息等 URIURI(Uniform Resource Identifier)指一个字符串用于标示某一个互联网资源，类似于资源的身份证 URI包括了URL(占绝大多数)和URI(未来趋势) URL定义URL(Uniform Resource Locator)指的是通过位置相关信息来对一个互联网资源进行标示，当资源(文件)移动位置，就会失去效果 语法1&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt; 一般的URL包含了最重要的3个部分，scheme、host和path 也有特殊的URL，比如mailto:wmcs@xxx.cn不符合该规则 path后面的params、query、frag由web的开发者利用 相对URL关于相对URL的具体解析算法在36页，总的来说算法如下： scheme为空说明是相对URL，否则为绝对URL 相对URL继承基础URL(当前环境)的host,user,password,scheme和port 前导为./我理解为是相对当前资源进行跳转, 例如 http://www.a.com/b/c/d.html中，点击./e.html会跳转到http://www.a.com/b/c/e.html 前导为/我理解是基于根domain跳转，例如3中的例子点击/e.html会跳转到http://www.a.com/e.html URL字符集URL仅允许使用ASCII的一个子集，非这个集合内的字符都需要转移，通过一个百分号加十六进制ASCII码完成 例如空格在URL中为%20。 包括. ? # %都具有特殊用途，全部表参考书中39页 URNURL具有一个显著的缺点: 当资源移动后，我们无法根据位置来找到他们。人们希望设计一个与位置无关的，永久存在的标记命名一个资源。能够随时随地获取 URN就是这样思想下的产物，一个资源具有一个始终稳定的名称。但是因为其实现难度(需要对资源登记，追踪，解析URN)始终没有推广与标准化 PURL(persistent URL)是这个思想的一种URL实现，将URL登记在一个中间层中，当URL改变，更新中间层的缓存，从而始终用一个URL从中间层访问资源，例如：1234对于资源A的URL http://www.hardware.com可以注册到中间层 http://purl.org/shop当资源A改变URL到 http://www.software.com 时，通知中间层我们依然可以用 http://purl.org/shop 访问该资源]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端常见面试问题(Keep updating)]]></title>
      <url>%2F2017%2F03%2F21%2F%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[Browser浏览器引擎 渲染引擎：获取解析网页内容，构建DOM、CSS等，计算网页layout，绘制网页 JavaScript引擎：解释执行JavaScript 随着JavaScript的发展，分离出了JavaScript引擎。 浏览器内核 Trident: IE系，包括360，搜狗 Gecko: Firefox系 WebKit: Safari系，以及魔改版Webkit的Chrome HTMLHTML5新特性 语义化标签 音频视频API Canvas API localStorage 与 sessionStorage WebSocket 语义化在HTML5中，所有标签具有其书面上的语义，即具有他要传递的内容是什么。语义与显示分离，显示全部由CSS3负责。 优点： 提升可访问性(对于使用ScreenReader)与互操作性 改进搜索引擎优化 一般使HTML文件更小 更好维护，表示层在CSS中 语义标签 &lt;nav&gt;导航标签，里面通常是列表&lt;ul&gt;或者&lt;ol&gt; &lt;article&gt;表示一个页面、文档、应用、容器，对&lt;section&gt;的聚合 &lt;section&gt;表示文章中的一个段落、一个对话框的标签页等 &lt;aside&gt;侧栏标签，包括侧边栏、广告、友情链接等 &lt;label for=&quot;xx&quot;&gt;定义form关系，点击label会跳转到相关的input上 Cookie与localStorage、sessionStorage区别 （多标签页之间通信）cookie小于4kb，在每次http请求中携带，具有设定的有效期 localStorage和sessionStorage大于4MB，永久存储／关闭窗口后消失，保存在本地 离线存储网页在没有因特网时通过缓存使用网页，在有网络连接时更新网页缓存 用法： 123&lt;html manifest = "cache.manifest"&gt;...&lt;/html&gt; 在cache.mainfest文件内书写缓存规则： CACHE:表示需要离线存储的资源列表 NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储 FALLBACK: 如果第一个资源访问失败，就访问第二个资源替代 CSS盒模型content + padding + border + margin box-sizing属性: content-box(默认值) or border-box，前者width指定content的宽度，后者width指定了content+padding+border的宽度 块级元素与行内元素display: block块级元素具有自定义的width、height属性，并且左右换行 display: inline行内元素不具有width等属性，由内容撑开，左右不换行 display: inline-block左右不换行的行内显示，但是可以指定width和height等属性。 Float与清除浮动浮动元素脱离文档流。浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。 可以实现文字环绕图片，但是浮动可能导致的问题。Image的父容器div依靠内部元素撑开，如果图片浮动，父div: 父元素height无法被撑开 背景不显示(因为没有height) margin值不正确显示 解决方法: 给父元素添加属性overflow: auto 加入一个兄弟节点，具有属性clear: both 将上面方法用CSS after实现 文档流(normal flow)与定位(Position)文档流是相对于盒模型来讲的，指从左到右从上到下的正常布局 float: left、position: fixed、position: absolute会导致DOM脱离文档流，位于上一层 static：忽略top、left、z-index等声明，出现在正常文档流 relative：相对于其正常位置 absolute：相对于非static的最近祖先 fixed：相对于浏览器窗口 可以通过z-index来改变文档堆叠顺序，其计算顺序为: 子元素的z-index不能大于其父元素，越大越位于上方。 CSS选择器和权重以 10 为基本单位1000.内敛选择器 &gt; 100.ID选择器 &gt; 10.class选择器 &gt; 1.元素选择器 同优先级最后一个覆盖前一个 垂直/水平居中的实现方法方法一： 利用绝对定位123456.vertical &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);&#125; 方法二： 利用table的效果(父级container高度自适应)12345678#wrapper &#123; display: table;&#125;#cell &#123; display: table-cell; vertical-align: middle;&#125; 方法三： flex布局 通过align-self: center属性实现交叉轴（竖直方向）的居中 单行文字垂直居中： 设置line-height与height相等 多行文字垂直居中： 设置padding-top等于padding-bottom 设置一个span包围多行文字，设置span为diplay:block，然后可以设置vertical-align JavaScript延迟加载JS的方法 defer 和 async 动态创建DOM，创建script标签，设置src属性并插入DOM tree(JSONP的实现) 原生JS操作1234567891011121314151617181920212223//创建与添加createElement(); //创建一个具体的元素createTextNode(); //创建一个文本节点parentNode.appendChild();parentNode.insertBefore(newNode, referenceNode);//删除单个节点parent.removeChild(child);node.parentNode.removeChild(node);//替换DOM节点parentNode.replaceChild(newChild, oldChild);//节点移动属性element.parentNode; element.nextSibling; element.previousSibling;element.childNodes; //返回数组element.firstChild; element.lastChild;//查找DOM节点document.getElementById();document.getElementsByClassName();document.getElementsByTagName();document.querySelectorAll(); //具有更广泛的选择性(接受CSS Selector)，IE8兼容 Web优化策略 请求数量：合并脚本和样式表, iconfont，拆分初始化负载（一开始只加载必要脚本），划分主域（增加DNS查询代价，但是增加了并发链接数） 请求带宽：开启 GZip，精简 JavaScript，移除重复脚本，图像优化 利用缓存：使用 CDN，使用外部 JavaScript 和 CSS，减少 DNS 查找 页面结构：将样式表(影响样式的内容)放在顶部，将脚本放在底部，尽早刷新文档的输出 Web应用从服务器主动推送Data到客户端 HTML5提供的WebSocket AJAX 长链接 AJAX 长轮询 一个页面从输入URL到加载完成的过程 键盘按下发出中断，扫描其接口信息，经过操作系统传递给应用（浏览器）； 浏览器开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理； 通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求； 进入HTTP会话； 服务器端Apache、Node.JS等响应请求，根据路由，经过相应应用（中间件）处理； 结束处理，如果修改时间和缓存一致返回304，否则返回200和该资源； HTML一边下载一边解析，根据标签建立文档树 DOM； 根据标记下载所需CSS、JS、图片文件，CSS阻塞式简历CSSOM，最终合并DOM和CSSOM，形成render tree，进行layout和painting； 当 JS 运行完成，页面加载完成。 new操作符做了什么 新建一个空白对象，并且继承该函数的原型，然后用this引用该对象 添加属性和方法 隐式返回this JavaScript继承12SubClass.prototype = Object.create(SuperClass.prototype); //子类原型继承自父类SubClass.prototype.constructor = SubClass; //修改constructor 闭包闭包是一个嵌套在内层的函数和被他所捕获的外层变量121. 闭包是指函数有自由独立的变量。也就是，定义在闭包中的函数可以“记忆”它创建时候的环境（即其作用域存在的所有变量）。2. 闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境（两者合起来可以视作为整个外层函数 makeFunc 的返回值 myFunc） 跨域及其解决方案 (腾讯)详情参见同源政策与跨域详解 CORS: 需要浏览器+服务器的支持。浏览器在Header中加入Origin字段，如果Origin在许可范围，服务器返回响应多出几个Access-Control字段 // Todo：CORS详解，同服务器不同域名请求 (腾讯) JSONP: 123JSONP在URL中向服务器传递一个callback function，在JavaScript中定义了该function的行为。当服务器端接收到请求后，将数据用该function包括起来，类似于 jsonp(data) &#123; ... &#125;并返回该脚本文件。客户端接收到请求后，自动运行之前定义个callback function，即对跨域数据进行了操作 AJAX操作 创建XMLHttpRequest对象 （状态0） 设置HTTP请求状态变为4（完成）时的回调函数 通过OPEN创建请求，指定方法，URL等 （状态1） SEND发送请求 (状态2) 使用JavaScript实现DOM刷新 (状态3下载，4时调用回调函数) 利用setTimeout多次调用在其回调函数再次调用自身即可 事件冒泡与事件捕获 事件冒泡：从子元素到父元素依次触发其上事件的回调函数 事件捕获：先触发父元素上的事件，再向下依次传递到子元素 在addEventListener中，第三个参数设置为true启用事件捕获。当既存在事件冒泡，又存在事件捕获时，优先事件捕获 事件代理／事件委托 (jQuery 中 bind 和 on)的区别事件委托将需要多个子元素触发的事件绑定到父元素上，通过 e.target 来判断是否是指定的子元素，进而触发回调 Attribute 和 Property 的区别前者是DOM作为HTML标签的属性，后者是DOM作为JavaScript对象的属性。 共同点：许多attribute具有对应的property 不同点：用户自定义的attribute和自定义的property之间没有关系 Promise 规范解决了之前异步操作的Callback Hell，将横向的操作变为了纵向的操作。具有4种状态：pending、fulfilled、rejected、settled。 使用：将之前的异步回调包装进Promise，操作成功调用resolve、失败调用reject。然后在then中运行原本的回调任务。 改变运行上下文方法：bind、apply、call 用处：绑定上下文（保持其始终获取某个上下文）、代理函数（自定义log代理console.lo）等 如何让接受多个参数的函数接受一个数组作为参数(例如 Math.max) (讯飞)1234//方法1Math.max.apply(Math, [1,2,3,4,5]);//方法2 ES6Math.max(...[1,2,3,4,5]); DOM操作性能 使用变量缓存DOM查询结果，减少查询操作 减少导致页面重绘(layout painting)的操作(改变widht、height。使用CSS动画） 使用更加精准的选择器（id选择器、类选择器） 前端渲染与后端渲染比较前端渲染不利于SEO，服务器端为了前端渲染，需要花费更多时间将对象字符串化 后端渲染增大了网络传输体积与损耗，容易造成延时（白屏） Virtual DOMDOM元素非常庞大，具有复杂的属性，牵一发而动全身。通过JavaScript来模拟DOM树的结构，加快响应时间 建立虚拟DOM树：用JavaScript对象记录节点类型、属性、子节点。通过递归该虚拟DOM建立真正的DOM树 diff算法：因为跨层DOM操作很少，只比较同层DOM，从而将O(n^3)的比较降低到O(n)复杂度，深度优先遍历，记录差异： 替换节点类型： div -&gt; p 增、删、调换子节点 修改节点属性 修改文本内容 记录差异类型，差异内容，压入patch数组 根据patch数组，对真实DOM进行操作。 Babel 运行时 (腾讯)Babel可以编译几乎所有ES6语法(比如块级作用域，class语法糖)，但是对于环境不支持的API没有办法，解决方案主要是： babel-polyfill: 在全局对象global上挂载对象API，比如Promise等，缺点是会污染模块使用者 babel-runtime: 手动在模块中require需要的API，比如const Promise = require(&#39;babel-runtime/core-js/promise&#39;)，缺点是打包可能存在多个引入语句，通过babel-plugin-transform-runtime模块重新打包避免这个问题 JSON概念，作用，结构JSON是一种数据格式，可以用来交换、存储数据。从JSON可以方便的生成JS对象。 其语法可以认为是JS Object的子集，主要区别在： JSON的键必须带引号，JS可以不带（解释器自动加） JSON没有函数、undefined、NaN等数据类型 网络TCP 协议的三次握手 Client -&gt; Server : SYN = 1, SEQ = x Server -&gt; Client : SYN = 1, ACK = x+1, SEQ = y Client -&gt; Server : ACK = y+1, 可以携带payload HTTP状态码 1**：暂时性回复。表示接收到请求并且继续处理 2**：响应成功。表示动作被成功接收、理解和接受 3**：重定向。 301：请求的网页已永久移动 302：临时重定向 304：自从上次请求，内容未更改过 4**：错误请求类 403：禁止访问 404：找不到如何与 URI 相匹配的资源 5**：服务器内部错误 WebSocket在HTTP中，链接必须严格遵守1 request 1 response的规范，并具有HTTP header开销 WebSocket是一种兼容现有浏览器握手规范的新协议。用于实现低延迟的长链接，双方都可以随意发送数据。解决了以往需要用AJAX长轮询实现的推送，并且为浏览器FPS等低延迟需求带来可能。 缺点目前主要是浏览器兼容性，服务器维持长链接也需要一定成本。 安全TLS(SSL) 原理详解 (腾讯)HTTPS可能被监听/篡改吗？// Todo…. SQL注入通过把SQL命令插入到Web表单中递交，或插入到输入包含查询字符串（query string）的 url，最终达到欺骗服务器执行恶意的SQL命令 前端需要做到： 永远不信任用户输入，在后端对用户输入校验 加密密码等关键信息 CSRF在危险网站B，向信任网站A发出请求（如转账），因为携带了A的Cookie，所以A认为是你自己发出的 前端需要做到：使用Cookie中不保存的，不可伪造的数据 添加验证码 添加token并且验证 XSS攻击者向网站插入恶意HTML、JavaScript代码（比如留言板，论坛发帖），其他人看到时，将运行这段恶意代码 前端需要做到： 对用户输入的&lt;、&#39;等特殊字符加以过滤 转义特殊字符到HTML]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[同源政策与跨域详解]]></title>
      <url>%2F2017%2F03%2F21%2F%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E4%B8%8E%E8%B7%A8%E5%9F%9F%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[跨域的应用场景在 Web2.0 时代，许多应用需要聚合信息(比如来自google, 来自wikipedia的内容)，因此来自A站点的网页，往往需要读取来自B的内容，这是受到同源策略约束的。 什么是同源政策(same-origin policy) 协议相同(FTP、HTTP等) 域名相同(包括每一级域名, foo.com和www.foo.com不同) 端口相同 以下行为受到限制(通常是跨域读操作): Cookie、LocalStorage、IndexDB 等存储性内容 DOM 节点 AJAX 请求不能发送 为什么需要同源政策保护用户隐私信息，防止身份伪造等(读取Cookie) 跨域写操作与跨域嵌入操作一般不受到约束。具体参考MDN 非AJAX的跨站请求document.domain 共享 DOM 与 存储对于只有前缀(二级、三级等域名)不同的网页，可以设置 document.domian 来规避同源策略 123456//对于 s1.a.com 和 s2.a.com，设置以下内容可以获取cookiedocument.domain = 'a.com'//document.domain 必须是域名的后缀，对于s1.a.comdocument.domain = 'a.com' //Right!document.domain = 'b.com' //Error! 'b.com' is not a suffix of 'a.com' 具有相同domian的可以互相读取Cookie：123456// s1.a.comdocument.cookie = "test1=hello";// s2.a.comvar allCookie = document.cookie;//服务器设定cookie的domainSet-Cookie: key=value; domain=.example.com; path=/ 也可以读取iframe内的DOM节点 fragment identifier 共享 DOMfragment identifier 指的是URL中hash符号#后面的内容，不引起页面刷新 父窗口可以改变子窗口的fragment identifier，反之亦然12345678//改变子窗口的urlvar src = originURL + '#' + data;document.getElementById('myIFrame').src = src;//子窗口响应事件window.onhashchange = function () &#123;&#125;//子窗口改变父窗口的hashparent.location.href= target + "#" + hash; window.namewindow.name最早是用来规避cookie缺点设立的(cookie过小, API复杂)，window支持2MB以上大小 name是window的一个属性，无论window的内容如何改变其值不发生变化，因此利用iframe标签页和window.name可以实现跨域 首先要简单了解iframe的相关知识，iframe在网页中创建了一个内联框架，通过src属性指向其他网站，每一个iframe都有一个包裹他的window，他是主窗口的子窗口 由此，跨站方案就非常简单了，我们首先声明一个iframe标签指向跨站的网站，在跨站的页面内设置window.name，当检测到onload(只运行一次)以后把src设置回同域站点然后读取 1234567891011121314151617let iframe = document.createElement('iframe');iframe.style.display = 'none';let state = 0; //用state控制onload只运行一次，避免来回刷新iframe.onload = function() &#123; if (state === 0) &#123; state = 1; iframe.contentWindow.location = '同源域名' &#125; else if (state === 1) &#123; let data = JSON.parse(iframe.contentWindow.name); //... do something with data document.body.removeChild(iframe) &#125;&#125;iframe.src = '跨域站点';document.body.appendChild(iframe) 这一解决方法的缺点主要在于需要使用iframe并且监听子窗口，影响了网页的性能 window.postMessageHTML5中引入, 用于跨域的父子窗口通信，不受同源策略限制.通过postMessage API可以实现对存储的读写，DOM的操作等 123456789var popup = window.open('http://bbb.com', 'title');//父窗口向子窗口发送消息popup.postMessage('Hello World!', 'http://bbb.com');//子窗口向父窗口发送消息window.opener.postMessage('Nice to see you', 'http://aaa.com');//父子都可以监听message事件响应window.addEventListener('message', function(e) &#123; console.log(e.data);&#125;,false); AJAX跨域WebSocketWebSocket通信协议不实行同源政策 JSONPJSONP优点是兼容性好，缺点是仅支持get方法具有局限性 其设计思路是因为浏览器不对 &lt;script&gt; 标签进行限制，因此可以利用这一点来进行跨域请求。 声明一个回调函数，其参数为要获取(服务器提供的data)，对参数进行操作(比如渲染进DOM) create一个&lt;script&gt;标签动态加入DOM tree，在src的URL中向服务器传递该函数名 服务器返回一个js脚本文件，将数据包括在url中给的回调函数里，运行回调函数 CORS阮一峰的文章写的非常清晰易懂 CORS要求浏览器(&gt;IE10)和服务器的同时支持，是跨域的根本解决方法，由浏览器自动完成优点在于功能更加强大支持各种HTTP Method，缺点是兼容性不如JSONP 简单请求定义满足以下全部2个条件的就是简单请求，否则是非简单请求 使用以下三个方法之一: GET、POST、HEAD HTTP头不超过以下几个字段 Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 流程浏览器将在请求头加入origin字段指定源，如果服务器支持并且该源在白名单里，将返回一个包含特殊头字段的响应，否则不包含这些特殊头字段，XMLHttpRequest 可以捕获错误，但是响应状态代码依然会是200 多出的字段： Access-Control-Allow-Origin(必须): 值为 * 或者请求的origin Access-Control-Allow-Credentials(可选): 值只能为true表明发送cookie，默认不发送cookie不包含该字段，需要设置xhr.withCredentials = true; Access-Control-Expose-Headers(可选): XMLHttpRequest.getResponseHeader()方法只可以获取Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma六个基本字段和该头字段指定的字段名的值 非简单请求预检请求(Preflight)对于非简单请求(非基本Method和Header，需要首先发送一个OPTIONS请求询问服务器是否支持浏览器根据AJAX的请求Method和Header，自动加入字段： Origin: 跨域必须指定的Origin Access-Control-Request-Method: 指定了请求要用到的方法，比如PUT Access-Control-Request-Headers(可选): 一个逗号分隔的字符串，指定了可能的额外Header字段 服务器检查自身是否支持后，进行回应： 否定预见请求: 返回没有任何CORS字段(Access-Control)的正常响应，可以用XMLHTTPRequest对象的 onerror 捕捉处理 肯定预见请求: 1. Access-Control-Allow-Methods: GET, POST, PUT (回复支持的方法) 2. Access-Control-Allow-Headers(如果请求具有): 逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。 3. Access-Control-Allow-Credentials: 是否传递cookie，同简单请求 4. Access-Control-Max-Age(可选): 表面预检的有效期，有效期内不发送预检请求 正常请求在预检请求之后，正常请求与简单请求类似，请求具有Origin段，回复具有Access-Control-Allow-Origin等字段。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6-Class]]></title>
      <url>%2F2017%2F03%2F14%2FES6-Class%2F</url>
      <content type="text"><![CDATA[Class Syntax in ES6概述在ES6中，可以通过Class来声明构造函数，可以认为Class是过去构造器写法的一种语法糖 123class a &#123;&#125;typeof a; //"function" 声明语法在Class中，依然存在prototype，依然是通过new关键字来声明一个实例 123456789101112class Point &#123; //constructor类似于之前的构造函数，实例变量在此声明 //事实上constructor方法在prototype上，指向类本身，与ES5一致 constructor(x, y) &#123; this.x = x; this.y = y; &#125; //实例方法，此处是声明在prototype上,可以采用表达式作为函数名 toString() &#123; //...... &#125;&#125; ES6不一致行为 在类内部(如上面的toString)定义的方法，在ES6中默认为不可枚举的，而ES5中prototype上的方法是可枚举的 1234//ES 6Object.keys(Point.prototype); // []//ES 5Object.keys(Point.prototype); // ["toString"] 用Class声明的类必须使用new实例化，不能直接当作函数调用，否则报错 为了保证子类声明在父类之后，Class不存在变量提升 立即执行Class12345678let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;('张三'); 绑定实例方法上下文实例方法执行时可能会丢失他指向的this(默认是该实例)123const logger = new Logger();const &#123; printName &#125; = logger;printName(); // TypeError: Cannot read property 'print' of undefined 解决方法有2: this.printName = this.printName.bind(this) 使用箭头函数，箭头函数捕获上下文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6-块级作用域]]></title>
      <url>%2F2017%2F03%2F11%2FES6-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[提供了块级作用域。1234567在`for`循环中，每一次循环，循环索引变量都是全新的变量，并且仅存在本次循环中。 for循环中，循环头是循环体的父作用域for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abc&apos;; console.log(i);&#125; 无暂时性提升，形成死区let声明的变量，在声明前使用会报错，而不是像var一样得到undefined1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 当外层和内层定义同名变量，在内层变量声明前调用该变量同样报错123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 重复声明报错同一个块级作用域内，使用let和const声明一个已存在的变量(无论第一次是如何声明的)，报错 函数声明ES6允许在块级作用域声明函数，但是为了兼容性，浏览器行为与规范有所不同 ES6：函数具有块级作用域 ES5（浏览器行为）：函数提升到函数作用域最前。 使用函数赋值语句避免不同的行为差异]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6--模块化]]></title>
      <url>%2F2017%2F03%2F11%2FES6-%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
      <content type="text"><![CDATA[ES6 Module 设计思想与之前社区规范 CommonJS 和 AMD 相比，ES6 的 Module 设计思想强调静态化 带来的优点 12341.静态加载效率更高(按需加载部分内容)2.未来引入宏、类型检查等特性（静态化）3.前后端统一模块化标准4.未来新的浏览器API和扩展功能(Math等)通过模块提供 静态化的要求 1231.只能在顶层作用域完成加载(不允许函数内，分支块内)2.不能在import语句中使用变量3.模块化默认要求严模式(不需要加'use strict') 普通 export import 语法输出 export:1234567891011//输出必须是变量并且变量必须在大括号中export var lastName = 'Jackson';export &#123;firstName, lastName, year&#125;;export lastName //Error！没有大括号！//可以重命名外部接口function v2() &#123; ... &#125;export &#123; v2 as streamV2, v2 as streamLatestVersion&#125;; 输入 import:123456//导入变量必须在大括号中，并且与导出名同名import &#123;firstName, lastName, year&#125; from './profile';//导入重命名import &#123; lastName as surname &#125; from './profile';//使用 * 来进行整体加载，将所有加载的变量赋值到一个对象上import * as circle from './circle'; export default 命令为了快速上手，用户往往没有时间去看文档来学习需要导入的变量名，因此需要通过export default指令来输出 1234function foo() &#123;...&#125;;export default foo;//任意变量名皆可import bar from 'foo'; 本质上是将输出的变量赋值给了一个叫做default的变量，在导入时，default可以被任意命名 12345//以下语句等价export &#123;add as default&#125;;export default add;export default var a = 1; //Error！default本身就是赋值，不能跟声明语句 export 与 import 复合写法export { foo, bar } from &#39;my_module&#39;; 等价于 import { foo, bar } from &apos;my_module&apos;; export { foo, bar };]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript模块化--CommonJS, AMD and CMD]]></title>
      <url>%2F2017%2F03%2F08%2FJavaScript%E6%A8%A1%E5%9D%97%E5%8C%96--CommonJS%2C%20AMD%20and%20CMD%2F</url>
      <content type="text"><![CDATA[为什么需要模块化 防止变量名称空间污染 复杂的业务逻辑需要更好的分解/包装 没有规范的原始模块化 对象包裹模块(所有内容暴露在外) 123456789var module1 = new Object(&#123; _count : 0, m1 : function ()&#123; //... &#125;, m2 : function ()&#123; //... &#125;&#125;); 闭包实现私有变量 12345678910111213var module1 = (function()&#123; var _count = 0; var m1 = function()&#123; //... &#125;; var m2 = function()&#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;;&#125;)(); CommonJS规范因为服务器端的庞大代码和复杂业务逻辑的需求，相比浏览器端，模块化更加重要。Node.JS遵循了CommonJS的规范，并做出了一些取舍。 CommonJS主要内容： 每个文件是一个模块，全局变量必须通过 global.variable 进行声明 module.exports 属性是模组暴露的接口，在上面添加变量/函数 require 加载模块，实际上加载的就是 module.exports 对于更多的技术细节不再具体探讨，网上有着更多的资料 AMD规范对于服务器端，CommonJS采用了同步加载的方法，类似于其他语言，其加载延迟取决于硬盘速度，但是在前端浏览器中，因为网络带宽的原因，多个文件加载会导致： JavaScript文件加载会阻塞网页渲染，导致未响应 依赖关系导致了复杂的加载顺序，容易出错 AMD规范定义了异步加载，加载完相应模块后，再调用依赖这些模块的回调函数。简单来说，AMD就是这一个接口： 1define(['dep1','dep2'],function(dep1,dep2)&#123; ... &#125;); RequireJS实现了AMD规范，首先需要加载requireJS文件： 1&lt;script src="js/require.js" data-main="js/main"&gt;&lt;/script&gt; 之后采用AMD规范编写/加载模块: 12345678910111213//定义模块define(function ()&#123; let add = function (x,y)&#123; return x+y; &#125;; return &#123; add: add &#125;;&#125;);//加载模块require(['jquery', 'underscore', 'backbone'], function ($, _, Backbone)&#123; // some code here&#125;); CMD规范与AMD规范的RequireJS最大区别： AMD依赖前置：RequireJS预加载所有模块，并且执行顺序不一定。 CMD就近依赖：SeaJS(CMD规范)按需加载，更符合代码顺序。但是牺牲了性能（可以忽略不计）。]]></content>
    </entry>

    
  
  
</search>
