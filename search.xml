<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[前端常见面试问题(Keep updating)]]></title>
      <url>%2F2017%2F03%2F21%2F%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[Browser浏览器引擎 渲染引擎：获取解析网页内容，构建DOM、CSS等，计算网页layout，绘制网页 JavaScript引擎：解释执行JavaScript 随着JavaScript的发展，分离出了JavaScript引擎。 浏览器内核 Trident: IE系，包括360，搜狗 Gecko: Firefox系 WebKit: Safari系，以及魔改版Webkit的Chrome HTMLHTML5新特性 语义化标签 音频视频API Canvas API localStorage 与 sessionStorage WebSocket 语义化在HTML5中，所有标签具有其书面上的语义，即具有他要传递的内容是什么。语义与显示分离，显示全部由CSS3负责。 优点： 提升可访问性(对于使用ScreenReader)与互操作性 改进搜索引擎优化 一般使HTML文件更小 更好维护，表示层在CSS中 语义标签 &lt;nav&gt;导航标签，里面通常是列表&lt;ul&gt;或者&lt;ol&gt; &lt;article&gt;表示一个页面、文档、应用、容器，对&lt;section&gt;的聚合 &lt;section&gt;表示文章中的一个段落、一个对话框的标签页等 &lt;aside&gt;侧栏标签，包括侧边栏、广告、友情链接等 &lt;label for=&quot;xx&quot;&gt;定义form关系，点击label会跳转到相关的input上 Cookie与localStorage、sessionStorage区别 （多标签页之间通信）cookie小于4kb，在每次http请求中携带，具有设定的有效期 localStorage和sessionStorage大于4MB，永久存储／关闭窗口后消失，保存在本地 离线存储网页在没有因特网时通过缓存使用网页，在有网络连接时更新网页缓存 用法： 123&lt;html manifest = "cache.manifest"&gt;...&lt;/html&gt; 在cache.mainfest文件内书写缓存规则： CACHE:表示需要离线存储的资源列表 NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储 FALLBACK: 如果第一个资源访问失败，就访问第二个资源替代 CSS盒模型content + padding + border + margin box-sizing属性: content-box(默认值) or border-box，前者width指定content的宽度，后者width指定了content+padding+border的宽度 块级元素与行内元素display: block块级元素具有自定义的width、height属性，并且左右换行 display: inline行内元素不具有width等属性，由内容撑开，左右不换行 display: inline-block左右不换行的行内显示，但是可以指定width和height等属性。 Float与清除浮动浮动元素脱离文档流。浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。 可以实现文字环绕图片，但是浮动可能导致的问题。Image的父容器div依靠内部元素撑开，如果图片浮动，父div: 父元素height无法被撑开 背景不显示(因为没有height) margin值不正确显示 解决方法: 给父元素添加属性overflow: auto 加入一个兄弟节点，具有属性clear: both 将上面方法用CSS after实现 文档流(normal flow)与定位(Position)文档流是相对于盒模型来讲的，指从左到右从上到下的正常布局 float: left、position: fixed、position: absolute会导致DOM脱离文档流，位于上一层 static：忽略top、left、z-index等声明，出现在正常文档流 relative：相对于其正常位置 absolute：相对于非static的最近祖先 fixed：相对于浏览器窗口 可以通过z-index来改变文档堆叠顺序，其计算顺序为: 子元素的z-index不能大于其父元素，越大越位于上方。 CSS选择器和权重以 10 为基本单位1000.内敛选择器 &gt; 100.ID选择器 &gt; 10.class选择器 &gt; 1.元素选择器 同优先级最后一个覆盖前一个 垂直/水平居中的实现方法方法一： 利用绝对定位123456.vertical &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);&#125; 方法二： 利用table的效果(父级container高度自适应)12345678#wrapper &#123; display: table;&#125;#cell &#123; display: table-cell; vertical-align: middle;&#125; 方法三： flex布局 通过align-self: center属性实现交叉轴（竖直方向）的居中 单行文字垂直居中： 设置line-height与height相等 多行文字垂直居中： 设置padding-top等于padding-bottom 设置一个span包围多行文字，设置span为diplay:block，然后可以设置vertical-align JavaScript延迟加载JS的方法 defer 和 async 动态创建DOM，创建script标签，设置src属性并插入DOM tree(JSONP的实现) 原生JS操作1234567891011121314151617181920212223//创建与添加createElement(); //创建一个具体的元素createTextNode(); //创建一个文本节点parentNode.appendChild();parentNode.insertBefore(newNode, referenceNode);//删除单个节点parent.removeChild(child);node.parentNode.removeChild(node);//替换DOM节点parentNode.replaceChild(newChild, oldChild);//节点移动属性element.parentNode; element.nextSibling; element.previousSibling;element.childNodes; //返回数组element.firstChild; element.lastChild;//查找DOM节点document.getElementById();document.getElementsByClassName();document.getElementsByTagName();document.querySelectorAll(); //具有更广泛的选择性(接受CSS Selector)，IE8兼容 Web优化策略 请求数量：合并脚本和样式表, iconfont，拆分初始化负载（一开始只加载必要脚本），划分主域（增加DNS查询代价，但是增加了并发链接数） 请求带宽：开启 GZip，精简 JavaScript，移除重复脚本，图像优化 利用缓存：使用 CDN，使用外部 JavaScript 和 CSS，减少 DNS 查找 页面结构：将样式表(影响样式的内容)放在顶部，将脚本放在底部，尽早刷新文档的输出 Web应用从服务器主动推送Data到客户端 HTML5提供的WebSocket AJAX 长链接 AJAX 长轮询 一个页面从输入URL到加载完成的过程 键盘按下发出中断，扫描其接口信息，经过操作系统传递给应用（浏览器）； 浏览器开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理； 通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求； 进入HTTP会话； 服务器端Apache、Node.JS等响应请求，根据路由，经过相应应用（中间件）处理； 结束处理，如果修改时间和缓存一致返回304，否则返回200和该资源； HTML一边下载一边解析，根据标签建立文档树 DOM； 根据标记下载所需CSS、JS、图片文件，CSS阻塞式简历CSSOM，最终合并DOM和CSSOM，形成render tree，进行layout和painting； 当 JS 运行完成，页面加载完成。 new操作符做了什么 新建一个空白对象，并且继承该函数的原型，然后用this引用该对象 添加属性和方法 隐式返回this JavaScript继承12SubClass.prototype = Object.create(SuperClass.prototype); //子类原型继承自父类SubClass.prototype.constructor = SubClass; //修改constructor 闭包闭包是一个嵌套在内层的函数和被他所捕获的外层变量121. 闭包是指函数有自由独立的变量。也就是，定义在闭包中的函数可以“记忆”它创建时候的环境（即其作用域存在的所有变量）。2. 闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境（两者合起来可以视作为整个外层函数 makeFunc 的返回值 myFunc） 跨域及其解决方案 (腾讯)详情参见同源政策与跨域详解 CORS: 需要浏览器+服务器的支持。浏览器在Header中加入Origin字段，如果Origin在许可范围，服务器返回响应多出几个Access-Control字段 // Todo：CORS详解，同服务器不同域名请求 (腾讯) JSONP: 123JSONP在URL中向服务器传递一个callback function，在JavaScript中定义了该function的行为。当服务器端接收到请求后，将数据用该function包括起来，类似于 jsonp(data) &#123; ... &#125;并返回该脚本文件。客户端接收到请求后，自动运行之前定义个callback function，即对跨域数据进行了操作 AJAX操作 创建XMLHttpRequest对象 （状态0） 设置HTTP请求状态变为4（完成）时的回调函数 通过OPEN创建请求，指定方法，URL等 （状态1） SEND发送请求 (状态2) 使用JavaScript实现DOM刷新 (状态3下载，4时调用回调函数) 利用setTimeout多次调用在其回调函数再次调用自身即可 事件冒泡与事件捕获 事件冒泡：从子元素到父元素依次触发其上事件的回调函数 事件捕获：先触发父元素上的事件，再向下依次传递到子元素 在addEventListener中，第三个参数设置为true启用事件捕获。当既存在事件冒泡，又存在事件捕获时，优先事件捕获 事件代理／事件委托 (jQuery 中 bind 和 on)的区别事件委托将需要多个子元素触发的事件绑定到父元素上，通过 e.target 来判断是否是指定的子元素，进而触发回调 Attribute 和 Property 的区别前者是DOM作为HTML标签的属性，后者是DOM作为JavaScript对象的属性。 共同点：许多attribute具有对应的property 不同点：用户自定义的attribute和自定义的property之间没有关系 Promise 规范解决了之前异步操作的Callback Hell，将横向的操作变为了纵向的操作。具有4种状态：pending、fulfilled、rejected、settled。 使用：将之前的异步回调包装进Promise，操作成功调用resolve、失败调用reject。然后在then中运行原本的回调任务。 改变运行上下文方法：bind、apply、call 用处：绑定上下文（保持其始终获取某个上下文）、代理函数（自定义log代理console.lo）等 如何让接受多个参数的函数接受一个数组作为参数(例如 Math.max) (讯飞)1234//方法1Math.max.apply(Math, [1,2,3,4,5]);//方法2 ES6Math.max(...[1,2,3,4,5]); DOM操作性能 使用变量缓存DOM查询结果，减少查询操作 减少导致页面重绘(layout painting)的操作(改变widht、height。使用CSS动画） 使用更加精准的选择器（id选择器、类选择器） 前端渲染与后端渲染比较前端渲染不利于SEO，服务器端为了前端渲染，需要花费更多时间将对象字符串化 后端渲染增大了网络传输体积与损耗，容易造成延时（白屏） Virtual DOMDOM元素非常庞大，具有复杂的属性，牵一发而动全身。通过JavaScript来模拟DOM树的结构，加快响应时间 建立虚拟DOM树：用JavaScript对象记录节点类型、属性、子节点。通过递归该虚拟DOM建立真正的DOM树 diff算法：因为跨层DOM操作很少，只比较同层DOM，从而将O(n^3)的比较降低到O(n)复杂度，深度优先遍历，记录差异： 替换节点类型： div -&gt; p 增、删、调换子节点 修改节点属性 修改文本内容 记录差异类型，差异内容，压入patch数组 根据patch数组，对真实DOM进行操作。 Babel 运行时 (腾讯)Babel可以编译几乎所有ES6语法(比如块级作用域，class语法糖)，但是对于环境不支持的API没有办法，解决方案主要是： babel-polyfill: 在全局对象global上挂载对象API，比如Promise等，缺点是会污染模块使用者 babel-runtime: 手动在模块中require需要的API，比如const Promise = require(&#39;babel-runtime/core-js/promise&#39;)，缺点是打包可能存在多个引入语句，通过babel-plugin-transform-runtime模块重新打包避免这个问题 JSON概念，作用，结构JSON是一种数据格式，可以用来交换、存储数据。从JSON可以方便的生成JS对象。 其语法可以认为是JS Object的子集，主要区别在： JSON的键必须带引号，JS可以不带（解释器自动加） JSON没有函数、undefined、NaN等数据类型 网络HTTP状态码 1**：暂时性回复。表示接收到请求并且继续处理 2**：响应成功。表示动作被成功接收、理解和接受 3**：重定向。 301：请求的网页已永久移动 302：临时重定向 304：自从上次请求，内容未更改过 4**：错误请求类 403：禁止访问 404：找不到如何与 URI 相匹配的资源 5**：服务器内部错误 WebSocket在HTTP中，链接必须严格遵守1 request 1 response的规范，并具有HTTP header开销 WebSocket是一种兼容现有浏览器握手规范的新协议。用于实现低延迟的长链接，双方都可以随意发送数据。解决了以往需要用AJAX长轮询实现的推送，并且为浏览器FPS等低延迟需求带来可能。 缺点目前主要是浏览器兼容性，服务器维持长链接也需要一定成本。 安全TLS(SSL) 原理详解 (腾讯)HTTPS可能被监听/篡改吗？// Todo…. SQL注入通过把SQL命令插入到Web表单中递交，或插入到输入包含查询字符串（query string）的 url，最终达到欺骗服务器执行恶意的SQL命令 前端需要做到： 永远不信任用户输入，在后端对用户输入校验 加密密码等关键信息 CSRF在危险网站B，向信任网站A发出请求（如转账），因为携带了A的Cookie，所以A认为是你自己发出的 前端需要做到：使用Cookie中不保存的，不可伪造的数据 添加验证码 添加token并且验证 XSS攻击者向网站插入恶意HTML、JavaScript代码（比如留言板，论坛发帖），其他人看到时，将运行这段恶意代码 前端需要做到： 对用户输入的&lt;、&#39;等特殊字符加以过滤 转义特殊字符到HTML]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[同源政策与跨域详解]]></title>
      <url>%2F2017%2F03%2F21%2F%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E4%B8%8E%E8%B7%A8%E5%9F%9F%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[跨域的应用场景在 Web2.0 时代，许多应用需要聚合信息(比如来自google, 来自wikipedia的内容)，因此来自A站点的网页，往往需要读取来自B的内容，这是受到同源策略约束的。 什么是同源政策(same-origin policy) 协议相同(FTP、HTTP等) 域名相同(包括每一级域名, foo.com和www.foo.com不同) 端口相同 以下行为受到限制(通常是跨域读操作): Cookie、LocalStorage、IndexDB 等存储性内容 DOM 节点 AJAX 请求不能发送 为什么需要同源政策保护用户隐私信息，防止身份伪造等(读取Cookie) 跨域写操作与跨域嵌入操作一般不受到约束。具体参考MDN 非AJAX的跨站请求document.domain 共享 DOM 与 存储对于只有前缀(二级、三级等域名)不同的网页，可以设置 document.domian 来规避同源策略 123456//对于 s1.a.com 和 s2.a.com，设置以下内容可以获取cookiedocument.domain = 'a.com'//document.domain 必须是域名的后缀，对于s1.a.comdocument.domain = 'a.com' //Right!document.domain = 'b.com' //Error! 'b.com' is not a suffix of 'a.com' 具有相同domian的可以互相读取Cookie：123456// s1.a.comdocument.cookie = "test1=hello";// s2.a.comvar allCookie = document.cookie;//服务器设定cookie的domainSet-Cookie: key=value; domain=.example.com; path=/ 也可以读取iframe内的DOM节点 fragment identifier 共享 DOMfragment identifier 指的是URL中hash符号#后面的内容，不引起页面刷新 父窗口可以改变子窗口的fragment identifier，反之亦然12345678//改变子窗口的urlvar src = originURL + '#' + data;document.getElementById('myIFrame').src = src;//子窗口响应事件window.onhashchange = function () &#123;&#125;//子窗口改变父窗口的hashparent.location.href= target + "#" + hash; window.namewindow.name最早是用来规避cookie缺点设立的(cookie过小, API复杂)，window支持2MB以上大小 name是window的一个属性，无论window的内容如何改变其值不发生变化，因此利用iframe标签页和window.name可以实现跨域 首先要简单了解iframe的相关知识，iframe在网页中创建了一个内联框架，通过src属性指向其他网站，每一个iframe都有一个包裹他的window，他是主窗口的子窗口 由此，跨站方案就非常简单了，我们首先声明一个iframe标签指向跨站的网站，在跨站的页面内设置window.name，当检测到onload(只运行一次)以后把src设置回同域站点然后读取 1234567891011121314151617let iframe = document.createElement('iframe');iframe.style.display = 'none';let state = 0; //用state控制onload只运行一次，避免来回刷新iframe.onload = function() &#123; if (state === 0) &#123; state = 1; iframe.contentWindow.location = '同源域名' &#125; else if (state === 1) &#123; let data = JSON.parse(iframe.contentWindow.name); //... do something with data document.body.removeChild(iframe) &#125;&#125;iframe.src = '跨域站点';document.body.appendChild(iframe) 这一解决方法的缺点主要在于需要使用iframe并且监听子窗口，影响了网页的性能 window.postMessageHTML5中引入, 用于跨域的父子窗口通信，不受同源策略限制.通过postMessage API可以实现对存储的读写，DOM的操作等 123456789var popup = window.open('http://bbb.com', 'title');//父窗口向子窗口发送消息popup.postMessage('Hello World!', 'http://bbb.com');//子窗口向父窗口发送消息window.opener.postMessage('Nice to see you', 'http://aaa.com');//父子都可以监听message事件响应window.addEventListener('message', function(e) &#123; console.log(e.data);&#125;,false); AJAX跨域WebSocketWebSocket通信协议不实行同源政策 JSONPJSONP优点是兼容性好，缺点是仅支持get方法具有局限性 其设计思路是因为浏览器不对 &lt;script&gt; 标签进行限制，因此可以利用这一点来进行跨域请求。 声明一个回调函数，其参数为要获取(服务器提供的data)，对参数进行操作(比如渲染进DOM) create一个&lt;script&gt;标签动态加入DOM tree，在src的URL中向服务器传递该函数名 服务器返回一个js脚本文件，将数据包括在url中给的回调函数里，运行回调函数 CORSCORS要求浏览器(&gt;IE10)和服务器的同时支持]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6-Class]]></title>
      <url>%2F2017%2F03%2F14%2FES6-Class%2F</url>
      <content type="text"><![CDATA[Class Syntax in ES6概述在ES6中，可以通过Class来声明构造函数，可以认为Class是过去构造器写法的一种语法糖 123class a &#123;&#125;typeof a; //"function" 声明语法在Class中，依然存在prototype，依然是通过new关键字来声明一个实例 123456789101112class Point &#123; //constructor类似于之前的构造函数，实例变量在此声明 //事实上constructor方法在prototype上，指向类本身，与ES5一致 constructor(x, y) &#123; this.x = x; this.y = y; &#125; //实例方法，此处是声明在prototype上,可以采用表达式作为函数名 toString() &#123; //...... &#125;&#125; ES6不一致行为 在类内部(如上面的toString)定义的方法，在ES6中默认为不可枚举的，而ES5中prototype上的方法是可枚举的 1234//ES 6Object.keys(Point.prototype); // []//ES 5Object.keys(Point.prototype); // ["toString"] 用Class声明的类必须使用new实例化，不能直接当作函数调用，否则报错 为了保证子类声明在父类之后，Class不存在变量提升 立即执行Class12345678let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;('张三'); 绑定实例方法上下文实例方法执行时可能会丢失他指向的this(默认是该实例)123const logger = new Logger();const &#123; printName &#125; = logger;printName(); // TypeError: Cannot read property 'print' of undefined 解决方法有2: this.printName = this.printName.bind(this) 使用箭头函数，箭头函数捕获上下文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6-块级作用域]]></title>
      <url>%2F2017%2F03%2F11%2FES6-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[提供了块级作用域。1234567在`for`循环中，每一次循环，循环索引变量都是全新的变量，并且仅存在本次循环中。 for循环中，循环头是循环体的父作用域for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abc&apos;; console.log(i);&#125; 无暂时性提升，形成死区let声明的变量，在声明前使用会报错，而不是像var一样得到undefined1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 当外层和内层定义同名变量，在内层变量声明前调用该变量同样报错123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 重复声明报错同一个块级作用域内，使用let和const声明一个已存在的变量(无论第一次是如何声明的)，报错 函数声明ES6允许在块级作用域声明函数，但是为了兼容性，浏览器行为与规范有所不同 ES6：函数具有块级作用域 ES5（浏览器行为）：函数提升到函数作用域最前。 使用函数赋值语句避免不同的行为差异]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6--模块化]]></title>
      <url>%2F2017%2F03%2F11%2FES6-%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
      <content type="text"><![CDATA[ES6 Module 设计思想与之前社区规范 CommonJS 和 AMD 相比，ES6 的 Module 设计思想强调静态化 带来的优点 12341.静态加载效率更高(按需加载部分内容)2.未来引入宏、类型检查等特性（静态化）3.前后端统一模块化标准4.未来新的浏览器API和扩展功能(Math等)通过模块提供 静态化的要求 1231.只能在顶层作用域完成加载(不允许函数内，分支块内)2.不能在import语句中使用变量3.模块化默认要求严模式(不需要加'use strict') 普通 export import 语法输出 export:1234567891011//输出必须是变量并且变量必须在大括号中export var lastName = 'Jackson';export &#123;firstName, lastName, year&#125;;export lastName //Error！没有大括号！//可以重命名外部接口function v2() &#123; ... &#125;export &#123; v2 as streamV2, v2 as streamLatestVersion&#125;; 输入 import:123456//导入变量必须在大括号中，并且与导出名同名import &#123;firstName, lastName, year&#125; from './profile';//导入重命名import &#123; lastName as surname &#125; from './profile';//使用 * 来进行整体加载，将所有加载的变量赋值到一个对象上import * as circle from './circle'; export default 命令为了快速上手，用户往往没有时间去看文档来学习需要导入的变量名，因此需要通过export default指令来输出 1234function foo() &#123;...&#125;;export default foo;//任意变量名皆可import bar from 'foo'; 本质上是将输出的变量赋值给了一个叫做default的变量，在导入时，default可以被任意命名 12345//以下语句等价export &#123;add as default&#125;;export default add;export default var a = 1; //Error！default本身就是赋值，不能跟声明语句 export 与 import 复合写法export { foo, bar } from &#39;my_module&#39;; 等价于 import { foo, bar } from &apos;my_module&apos;; export { foo, bar };]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript模块化--CommonJS, AMD and CMD]]></title>
      <url>%2F2017%2F03%2F08%2FJavaScript%E6%A8%A1%E5%9D%97%E5%8C%96--CommonJS%2C%20AMD%20and%20CMD%2F</url>
      <content type="text"><![CDATA[为什么需要模块化 防止变量名称空间污染 复杂的业务逻辑需要更好的分解/包装 没有规范的原始模块化 对象包裹模块(所有内容暴露在外) 123456789var module1 = new Object(&#123; _count : 0, m1 : function ()&#123; //... &#125;, m2 : function ()&#123; //... &#125;&#125;); 闭包实现私有变量 12345678910111213var module1 = (function()&#123; var _count = 0; var m1 = function()&#123; //... &#125;; var m2 = function()&#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;;&#125;)(); CommonJS规范因为服务器端的庞大代码和复杂业务逻辑的需求，相比浏览器端，模块化更加重要。Node.JS遵循了CommonJS的规范，并做出了一些取舍。 CommonJS主要内容： 每个文件是一个模块，全局变量必须通过 global.variable 进行声明 module.exports 属性是模组暴露的接口，在上面添加变量/函数 require 加载模块，实际上加载的就是 module.exports 对于更多的技术细节不再具体探讨，网上有着更多的资料 AMD规范对于服务器端，CommonJS采用了同步加载的方法，类似于其他语言，其加载延迟取决于硬盘速度，但是在前端浏览器中，因为网络带宽的原因，多个文件加载会导致： JavaScript文件加载会阻塞网页渲染，导致未响应 依赖关系导致了复杂的加载顺序，容易出错 AMD规范定义了异步加载，加载完相应模块后，再调用依赖这些模块的回调函数。简单来说，AMD就是这一个接口： 1define(['dep1','dep2'],function(dep1,dep2)&#123; ... &#125;); RequireJS实现了AMD规范，首先需要加载requireJS文件： 1&lt;script src="js/require.js" data-main="js/main"&gt;&lt;/script&gt; 之后采用AMD规范编写/加载模块: 12345678910111213//定义模块define(function ()&#123; let add = function (x,y)&#123; return x+y; &#125;; return &#123; add: add &#125;;&#125;);//加载模块require(['jquery', 'underscore', 'backbone'], function ($, _, Backbone)&#123; // some code here&#125;); CMD规范与AMD规范的RequireJS最大区别： AMD依赖前置：RequireJS预加载所有模块，并且执行顺序不一定。 CMD就近依赖：SeaJS(CMD规范)按需加载，更符合代码顺序。但是牺牲了性能（可以忽略不计）。]]></content>
    </entry>

    
  
  
</search>
